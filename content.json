{"meta":{"title":"悠哉码农的日常","subtitle":null,"description":null,"author":"悠哉码农的日常","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2019-09-27T12:38:44.000Z","updated":"2019-09-27T12:38:44.554Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"网课助手","slug":"网课助手","date":"2019-11-05T11:27:07.000Z","updated":"2019-11-05T14:22:13.966Z","comments":true,"path":"2019/11/05/网课助手/","link":"","permalink":"http://yoursite.com/2019/11/05/网课助手/","excerpt":"安装油猴脚本准备工具 油猴：油猴下载地址 提取码：7ecl 浏览器（建议cheome浏览器，其他自测）","text":"安装油猴脚本准备工具 油猴：油猴下载地址 提取码：7ecl 浏览器（建议cheome浏览器，其他自测） 安装步骤 解压油猴脚本到桌面 点击右上角三个点&gt;更多工具&gt;扩展程序 点击右上角的开发者模式&gt;选择已解压的扩展程序&gt;找到解压后的油猴脚本 安装好脚本后会有错误提示，重新打开浏览器可以了 浏览器输入地址：https://greasyfork.org/zh-CN/forum/ 这样就可以后台挂着网课，自动播放，自动答题","categories":[],"tags":[]},{"title":"C#序列化和反序列化","slug":"C-序列化和反序列化","date":"2019-11-04T14:51:33.000Z","updated":"2019-11-05T14:23:20.746Z","comments":true,"path":"2019/11/04/C-序列化和反序列化/","link":"","permalink":"http://yoursite.com/2019/11/04/C-序列化和反序列化/","excerpt":"序列化和反序列化概述序列化就是将对象实例的状态存储到存储媒体的过程","text":"序列化和反序列化概述序列化就是将对象实例的状态存储到存储媒体的过程 标记类为可序列化 12345[Serializable]class Student&#123; //&#125; 将实例化的对象序列化 1234567public void Save(Student stu)&#123; FileStream fs=new FileStream(stu.name+\".txt\",FileMode.Creat,FileAccess.Write); BinaryFormatter bf=new BinaryFormatter(); bf.Serialize(fs,stu);//序列化 fs.close();&#125; 反序列化 12345678public void Load(String path)&#123; Student stu=new Student(); FileStream fs=new FileStream(path,FileMode.Open,FileAccess.Read); BinaryFormatter bf=new BinaryFormatter(); stu=bf.Deserialize(fs) as Student;//反序列化 fs.Close();&#125;","categories":[],"tags":[]},{"title":"Es6","slug":"es6","date":"2019-10-25T05:23:12.054Z","updated":"2019-10-25T08:58:13.498Z","comments":true,"path":"2019/10/25/es6/","link":"","permalink":"http://yoursite.com/2019/10/25/es6/","excerpt":"ECMAScript 6.0，简称ES6，第一个版本是在2015年6月进行发布，所以也称之为《ECMAScript 2015 标准》（简称 ES2015）。 JavaScript是ECMAScript的一种实现（分支），遵循ECMAScript标准的。目前主流浏览器已经可以完美兼容和使用ES6。ES7/8部分新特性也已经被用于我们的实际开发中。","text":"ECMAScript 6.0，简称ES6，第一个版本是在2015年6月进行发布，所以也称之为《ECMAScript 2015 标准》（简称 ES2015）。 JavaScript是ECMAScript的一种实现（分支），遵循ECMAScript标准的。目前主流浏览器已经可以完美兼容和使用ES6。ES7/8部分新特性也已经被用于我们的实际开发中。 变量变量的作用域全局变量12345678910111213141516171819202122232425&#123; number=10;&#125;//不再同一个语句块里也可以访问到numbconsole.log(number);//使用var关键字声明的变量&#123; var fu=8;&#125;//可以访问到fu变量console.log(fu);//在if语句中声明var关键字的变量if(true)&#123; var i=7;&#125;//可以访问到i变量console.log(i);//在函数中声明var关键字的变量function fun()&#123; var j=9;&#125;//控制台会报错，找不到j变量console.log(j); 不带任何关键字声明的变量都是全局变量。不再函数中用var关键字声明的变量都是全局变量 箭头函数语法123456789&#123; //声明一个箭头函数赋值给fun let fun=(a,b)=&gt;&#123; return a+b; &#125; //调用fun并在在控制台输出 console.log(fun(1,2));&#125; ps：当参数只有一个时，小括号可以省略。当只有一个return语句时，大括号可以省略 简化箭头函数12345&#123; //隐式return，默认返回a*2； let fun=a=&gt;a*2; console.log(fun(1));&#125; 默认参数12345678&#123; //默认参数 //声明函数，3个形参，后两个有默认值 let fun=(a,b=2,c=3)=&gt;a+b+c; //调用函数时，可以只传一个参数 var show=fun(1); console.log(show);&#125; 在调用fun()时，也可以不输入任何参数，控制台会输出NaN 必填参数12345678910&#123; function ex()&#123; throw new(\"至少要输入一个参数\"); &#125; let fun=(x=ex(),y=1,z=2)=&gt;x+y+z; //不传入任何参数 var show=fun(); //此时控制台会报异常 console.log(show);&#125; 可变参数123456789101112&#123; //以计算任意数和为例 let sum=0; function fun(...arry)&#123; arry.forEach(item=&gt;&#123; return sum+=item; &#125;) &#125; //传入三个数字便可以计算出其和 fun(1,2,3); console.log(sum);&#125; ES6中字符串的新功能1234567891011&#123; var str=\"www.baidu.com\"; //str.startsWith(\"\");判断是否是指定字符串开头 if(str.startsWith(\"www\"))&#123; console.log(\"www开头\"); &#125; //str.endsWith(\"\");判断是否以制定字符串结尾 if(str.endsWith(\".com\"))&#123; console.log(\".com结尾\"); &#125;&#125; 字符串模板123456 &#123; var name=\"zhong\"; var age=19; //`$&#123;变量名&#125;`，相当于起到C#中占位符作用console.log(`姓名：$&#123;name&#125;，年龄：$&#123;age&#125;`)； &#125; 数组合并12345 var arry1=[1,2,3]; var arry2=[5,6,7]; //将arry1和arry2合并成为一个新的数组var newarry=[...arry1,...arry2];console.log(newarry); 数组遍历12345678910111213var arry=[1,2,5,6,3];//遍历数组的下标for(var inex of arry.keys())&#123; console.log(index);&#125;//遍历数组的值for(var val of arry)&#123; console.log(val);&#125;//遍历数组的值和下标for(var [inde,elems] in arry.entries())&#123; console.log(inde,elems);&#125; ES6新增创建对象的方法 ES6新增了一个class关键字，引入了类的概念 123456789101112131415class Student&#123; //构造方法 constructor(name,age)&#123; this.name=name; this.age=age; &#125; show()&#123; console.log(this.name,this.age); &#125;&#125;//实例化Student类var stu=new Student(\"stu1\",18);//调用show方法stu.show(); js面向对象之继承class可以用extends关键字实现继承（类似于java） 12345678910111213141516171819202122232425class Student&#123; //构造方法 constructor(name,age)&#123; this.name=name; this.age=age; &#125; show()&#123; return `$&#123;this.name&#125; $&#123;this.age&#125;`; &#125;&#125;class BoyStu extends Student&#123; constructor(name,age,able)&#123; super(name,age);//调用父类的构造方法 this.able=able; &#125; showBoy()&#123; return `$&#123;this.show()&#125;,$&#123;this.able&#125;`; &#125;&#125;var boy=new BoyStu(\"zhong\",18,\"打游戏\")；console.log(boy.showBoy());","categories":[],"tags":[]},{"title":"SQL Server触发器","slug":"SQL-Server触发器","date":"2019-10-09T12:15:14.000Z","updated":"2019-10-09T12:19:08.767Z","comments":true,"path":"2019/10/09/SQL-Server触发器/","link":"","permalink":"http://yoursite.com/2019/10/09/SQL-Server触发器/","excerpt":"","text":"##SQL Server触发器概述触发器是一个特殊的存储过程，它的执行不是由程序调用，也不是手工启动，而是当某一事件发生时触发，例如当表执行deletet insert update时就会被执行。触发器是用来为表数据的完整性 ###","categories":[],"tags":[]},{"title":"C#面向对象之泛型","slug":"C-面向对象之泛型","date":"2019-09-28T13:48:41.000Z","updated":"2019-09-28T14:30:21.104Z","comments":true,"path":"2019/09/28/C-面向对象之泛型/","link":"","permalink":"http://yoursite.com/2019/09/28/C-面向对象之泛型/","excerpt":"泛型概述泛型可将类型参数化，以达到代码的复用性，提高开发效率和代码的灵活性，泛型类是应用类型，是堆对象。泛型允许在定义数据类型的时候不事先指定其具体类型，在调用的时候才被确定。","text":"泛型概述泛型可将类型参数化，以达到代码的复用性，提高开发效率和代码的灵活性，泛型类是应用类型，是堆对象。泛型允许在定义数据类型的时候不事先指定其具体类型，在调用的时候才被确定。 泛型类程序员可以将一个类定义为一个泛型类，只需在类型的后面加个‘’，其中‘T’指的是要被传入的数据类型 123456789101112public class Student&lt;T&gt;&#123; //定义的时候不指定其数据类型 public T tests;&#125;static void Main(string[] args)&#123; //调用Student类 Student&lt;int&gt; stu=new Student&lt;int&gt;();//尖括号里传入数据类型，然后tests的数据类型就是传入的数据类型&#125; 泛型方法和泛型类一样，在方法的后面加一对‘’ 12345678910111213//顶一个方法计算两个变量的和，如果是数字，则计算和，是字符串则拼接这两个字符串public static void Add&lt;T&gt;(T a,T b)&#123; Console.WriteLine(a+b);&#125;static void Main(string[] args)&#123; //计算两个数字的和 Add&lt;int&gt;(1,2); //拼接字符串 Add&lt;string&gt;(\"abc\",\"def\");&#125; 泛型集合ListList和ArratList的使用方式大致相同，只不过是List在定义的时候要确定要被存储的数据类型，ArrayList则什么数据类型的对象都可以存入，所以List在获取元素的时候不需要强制转换，提高了类型的安全性 泛型字典集合Dictionary&lt;K,V&gt;同样的，Dictionary&lt;K,V&gt;的使用方式和Hashtable&lt;K,V&gt;的使用方式大致一样，Dictionary&lt;K,V&gt;在存入值和键的时候要指定其具体数据类型","categories":[],"tags":[]},{"title":"c#面向对象之字典集合Hashtable","slug":"c-面向对象之字典集合Hashtable","date":"2019-09-26T13:56:07.000Z","updated":"2019-09-26T15:33:25.898Z","comments":true,"path":"2019/09/26/c-面向对象之字典集合Hashtable/","link":"","permalink":"http://yoursite.com/2019/09/26/c-面向对象之字典集合Hashtable/","excerpt":"Hashtable概述在.NET中，Hashtable是用来处理 Key/Value（键/值）对的集合容器。其中Key通常用来快速查找，Value用来储存对应的Key值，Key区分大小写，Hashtable的Key和Values均为Object类型，所以在访问的时候要把类型从Object类型转换为原来的类型。相对于ArrayList，Hashtable更方便查找指定元素。","text":"Hashtable概述在.NET中，Hashtable是用来处理 Key/Value（键/值）对的集合容器。其中Key通常用来快速查找，Value用来储存对应的Key值，Key区分大小写，Hashtable的Key和Values均为Object类型，所以在访问的时候要把类型从Object类型转换为原来的类型。相对于ArrayList，Hashtable更方便查找指定元素。 Hashtable常用属性及方法Hashtable常用属性 属性 说明 Keys 获取包含Hashtable中所有键的ICollection,可以遍历该属性访问Hashtable中所有键 Values 获取包含Hashtable中所有值的ICollection,可以遍历该属性访问Hashtable中所有值 Count 获取Hashtable中键/值对的数目 Hashtable常用方法 方法 说明 Add(obgect keys,object values) 将带有指定键和值的元素添加到Hashtable中 Remove(object key) 删除Hashtable中指定键的元素 Clear() 清空Hashtable中所有的元素 ContainKey(object key) 判断Hashtable中是否包含指定键，该方法返回bool类型值 ContinVlue(object value) 判断Hashtable中是否包含指定值，该方法返回bool类型值 ps: 在Hashtable中的元素不需要按顺序储存，所以没有关于排序的方法 Hashtable的使用新建一个Student类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace ConsoleApp11&#123; class Student &#123; private string name; private int age; private bool sexCode; private char sex; public string Name &#123; get &#123; return name; &#125; set &#123; name = value; &#125; &#125; public int Age &#123; get &#123; return age; &#125; set &#123; age = value; &#125; &#125; public bool SexCode &#123; get &#123; return sexCode; &#125; set &#123; sexCode = value; &#125; &#125; public char Sex &#123; get &#123; if (SexCode == true) sex = '男'; else sex = '女'; return sex; &#125; &#125; /// &lt;summary&gt; /// 显示学生信息 /// &lt;/summary&gt; public void Show() &#123; Console.WriteLine(\"姓名：&#123;0&#125;，性别：&#123;1&#125;，年龄：&#123;2&#125;\", Name, Sex, Age); &#125; /// &lt;summary&gt; /// 用户查询学生姓名时显示对应的学生信息 /// &lt;/summary&gt; /// &lt;param name=\"name\"&gt;&lt;/param&gt; public void Show(string name) &#123; Console.WriteLine(\"你查询学生的信息如下\"); Console.WriteLine(\"姓名：&#123;0&#125;，性别：&#123;1&#125;，年龄：&#123;2&#125;\", Name, Sex, Age); &#125; &#125;&#125; 在Main函数中使用Hashtable，调用Student类 1234567891011121314151617181920212223242526272829303132333435//实例化两个学生类，添加两个学生Student zhong = new Student() &#123; Name = \"钟\", SexCode = true, Age = 19 &#125;;Student zhi = new Student() &#123; Name = \"智\", SexCode = false, Age = 19 &#125;;//实例化一个字典集合Hashtable,把学生的信息存入HashtableHashtable hst = new Hashtable();//存入学生信息，第一个参数是键 Keys（这里以学生的姓名为键），第二个参数是值 values （这里以学生信息对象为值）。//键和值 Keys&amp;&amp;Values 均为Object类型，所以在访问键值的时候都要转回储存前的类型hst.Add(zhong.Name,zhong);hst.Add(zhi.Name,zhi);//删除指定键的内容//hst.Remove(zhong.Name);//判断是否存在键，该值为bool值hst.ContainsKey(zhong.Name);//判断是否存在该内容，该值为bool值hst.ContainsValue(zhong);//用户输入学生信息Console.WriteLine(\"请输入你要查询学生的姓名\");string name= Console.ReadLine();//查询用户输入学生姓名，在Hashtable钟找出该学生的信息Student stu = hst[name] as Student;try&#123; //打印出该学生的信息 stu.Show(name);&#125;catch (Exception)&#123; //若查询不到则提示该学生信息不存在 Console.WriteLine(\"该学生信息不存在\");&#125;Console.ReadKey();","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"微信小程序实现横向滚动条功能","slug":"微信小程序实现横向滚动条功能","date":"2019-09-17T10:16:05.000Z","updated":"2019-09-18T07:42:49.135Z","comments":true,"path":"2019/09/17/微信小程序实现横向滚动条功能/","link":"","permalink":"http://yoursite.com/2019/09/17/微信小程序实现横向滚动条功能/","excerpt":"在微信小程序中实现用户可滑动的横向滚动导航栏效果","text":"在微信小程序中实现用户可滑动的横向滚动导航栏效果 效果图 导航栏的文本用户是可以滑动的 实现方法 在当前页面的js文件中的data块儿定义一个导航栏的文本数据集 1234567891011121314151617181920212223// 导航栏文本nvalist:[ &#123; text: '首页' &#125;, &#123; text: '动画' &#125;, &#123; text: '番剧' &#125;, &#123; text: '动画' &#125;, &#123; text: '国创' &#125;, &#123; text: '音乐' &#125;, &#123; text: '舞蹈' &#125;, &#123; text: '科技' &#125;, &#123; text: '游戏' &#125;, &#123; text: '娱乐' &#125;, &#123; text: '鬼畜' &#125;, &#123; text: '电影' &#125;, &#123; text: '电视剧' &#125;, &#123; text: '纪录片' &#125;, &#123; text: '影视' &#125;, &#123; text: '时尚' &#125;, &#123; text: '生活' &#125;, &#123; text: '广告' &#125;, &#123; text: '直播' &#125;, &#123; text: '相簿' &#125;,] 在wxml文件中书写如下标签,用来循环遍历在js中的导航栏文本 12345&lt;scroll-view class=\"nav\" scroll-x&gt;&lt;view bindtap=\"activeNav\" data-index=\"&#123;&#123;index&#125;&#125;\" class=\"nav_item &#123;&#123;index==currenentIndexNav?'active':''&#125;&#125;\" wx:for=\"&#123;&#123;nvalist&#125;&#125;\" wx:key=\"&#123;&#123;index&#125;&#125;\"&gt;&#123;&#123;item.text&#125;&#125;&lt;/view&gt;&lt;/scroll-view&gt; 在js中判断用户点击文本的索引值 12345678//定义被点击菜单的索引值 currenentIndexNav: 0, // 当用户点击文本后，显示相应的导航栏文本模块 activeNav(e)&#123; this.setData(&#123; currenentIndexNav:e.target.dataset.index &#125;) &#125;, wxss样式 123456789101112.nav&#123; white-space: nowrap; padding: 10rpx;&#125;.nav_item&#123; padding: 20rpx 45rpx; font-size: 30rpx; display: inline-block;&#125;.nav_item.active&#123; border-bottom: 5rpx solid pink;&#125;","categories":[],"tags":[]},{"title":"git命令基础篇","slug":"git命令基础","date":"2019-09-02T10:30:53.000Z","updated":"2019-09-07T09:05:18.754Z","comments":true,"path":"2019/09/02/git命令基础/","link":"","permalink":"http://yoursite.com/2019/09/02/git命令基础/","excerpt":"git是一款开源分布式管理控制系统，可以方便管理储存代码，托管你的代码，支持代码回滚，即回到过去git安装git安装地址 使用前配置配置用户信息与邮箱 git config –global user.name “你的账号”git config –global user.email “你的邮箱”","text":"git是一款开源分布式管理控制系统，可以方便管理储存代码，托管你的代码，支持代码回滚，即回到过去git安装git安装地址 使用前配置配置用户信息与邮箱 git config –global user.name “你的账号”git config –global user.email “你的邮箱” git工作流查看用户配置信息 git config –list 创建本地仓库 git init 创建文件夹 mkdir 文件夹名 创建文件 touch 文件名.html 删除文件 rm -rf 文件名 修改文件名 git mv file newfile (例如将a.txt修改为b.txt 命令: git mv a.txt b.txt) 提交代码到远端的4个步骤：查看文件状态（是否被提交，可省略） git status 添加文件到暂存区 git add 文件名 git add . 表示添加当前文件下所有文件 取消暂存区文件 git reset HEAD 文件名 填写提交信息 git commit -m “提交信息”跳过git add流程，自动把跟踪的文件全部提交git commit -a -m ‘added new benchmarks’ 将本地仓库推送到远端： git push 本地与远端同步： git pull 分支管理创建分支： git branch 分支名 切换分支： git checkout 分支名 创建并切换分支： git checkout -b 分支 （即创建分支与切换分支合并成一条命令） 分支合并： git merge 分支名 删除分支： git branch -d 分支名","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"使用CMD满速下载百度云","slug":"使用CMD满速下载百度云","date":"2019-08-07T13:10:59.000Z","updated":"2019-08-09T14:39:04.352Z","comments":true,"path":"2019/08/07/使用CMD满速下载百度云/","link":"","permalink":"http://yoursite.com/2019/08/07/使用CMD满速下载百度云/","excerpt":"工具准备 windows 10电脑 下载工具：baidupcs-go win10打开CDM快捷键 win+R后输入CMD回车 环境配置 桌面右击我的电脑→属性→高级系统设置→环境变量 在系统变量中选择Path变量→编辑→新建→输入你的BaiduPCS-Go的存放目录，注意是存放目录，例如我的是 D:\\BaiduPCS-Go-v3.5.6-windows-x64，最后依次确认这样才可以使用CMD命令快速打开baidupcs-go","text":"工具准备 windows 10电脑 下载工具：baidupcs-go win10打开CDM快捷键 win+R后输入CMD回车 环境配置 桌面右击我的电脑→属性→高级系统设置→环境变量 在系统变量中选择Path变量→编辑→新建→输入你的BaiduPCS-Go的存放目录，注意是存放目录，例如我的是 D:\\BaiduPCS-Go-v3.5.6-windows-x64，最后依次确认这样才可以使用CMD命令快速打开baidupcs-go 使用教程登录 配置好环境变量后，打开cmd 输入命令：baidupcs-go回车 登录你的百度网盘账号 输入命令 login回车依次输入账户密码，注意CMD中输入密码是不会显示出来的（哪怕是*号也不会显示）。 复制路径在文件管理器中粘贴打开 选择验证方式文件下载 列出当前位置所有文件 输入命令 ls 列出当前位置所有文件 选择目录（选择文件夹） cd 目录（只要输入前几个字按tab键就可以自动补全目录） 下载文件 d 文件名 总结至此，基本使用教程已经讲完了，也可以登录后输入命令‘help’查看命令集,如有其它问题前往 https://github.com/iikira/BaiduPCS-Go以获取更多帮助信息!前往 https://github.com/iikira/BaiduPCS-Go/releases 以获取程序更新信息!","categories":[],"tags":[{"name":"-百度云","slug":"百度云","permalink":"http://yoursite.com/tags/百度云/"}]},{"title":"winform实现B窗体刷新A窗体（子窗体刷新父窗体）","slug":"winform实现A窗体刷新B窗体","date":"2019-08-02T14:02:00.000Z","updated":"2019-08-05T06:32:18.019Z","comments":true,"path":"2019/08/02/winform实现A窗体刷新B窗体/","link":"","permalink":"http://yoursite.com/2019/08/02/winform实现A窗体刷新B窗体/","excerpt":"前言最近博主在做项目的时候遇到需要实现A窗体刷新B窗体的功能，比如从A窗体中点击登录按钮弹出B窗体的登录界面，如果用户登录成功则自动关闭B窗体，A窗体显示用户昵称；当用户关闭登录界面时，什么都不改变。","text":"前言最近博主在做项目的时候遇到需要实现A窗体刷新B窗体的功能，比如从A窗体中点击登录按钮弹出B窗体的登录界面，如果用户登录成功则自动关闭B窗体，A窗体显示用户昵称；当用户关闭登录界面时，什么都不改变。 效果流程 在A窗体中当用户点击登录，弹出B窗体登录界面，如果登录成功，则把A窗体用户名改成用户在B窗体输入的用户名 用户输入账户后，把账户传到A窗体中 解决方案实现窗体间的传值 重载A窗体中的构造方法，并定义一个string类型的全局变量，注意：必须加static关键字，否则不能传值 1234567891011121314//系统自动生成的构造函数 public Form1() &#123; InitializeComponent(); &#125; //定义一个string类型的全局变量 private static string UserName = \"\"; //重载构造函数，设置一个string类型的形参，用来接收从B窗体传来的值 public Form1(string str) &#123; //把传过来的参数赋值给UserName UserName = str; &#125; 在A窗体中定义一个方法，把要刷新的部分写到这个方法里面 12345public void ShuaXin()&#123; //吧用户名标签文本改成用户传过来的值 label1.Text = UserName;&#125; 在A窗体里点击触发B窗体的按钮里的代码如下 123456private void button1_Click(object sender, EventArgs e)&#123; Login login = new Login(); login.Owner = this; login.Show();&#125; 在B窗体登录按钮单击事件的代码如下 1234567private void button1_Click(object sender, EventArgs e)&#123; Form1 form1 = new Form1(textBox1.Text);//把用户输入的账户传到我们刚刚设置好的构造函数里 form1 = (Form1)Owner; form1.ShuaXin(); Close();&#125; 这样就可以实现我们的功能啦。","categories":[],"tags":[]},{"title":"ADO.NET连接数据库(DBHelper类)","slug":"ADO.NET连接数据库(DBHelper类)","date":"2019-07-28T12:11:11.000Z","updated":"2019-09-07T09:24:25.877Z","comments":true,"path":"2019/07/28/ADO.NET连接数据库(DBHelper类)/","link":"","permalink":"http://yoursite.com/2019/07/28/ADO.NET连接数据库(DBHelper类)/","excerpt":"ADO.NET概述ADO.NET是一种数据访问技术，使得应用程序可以连接到数据存储，并以各种方式操作存储在其中的数据。该技术基于.NET Framework，与.NET Framework类库的其余部分高度集成。ADO.NET API的设计，使得可以从所有面向.NET Framework的语言中使用该API，如Visual Basic、C#、J#、和Visual C++。ADO.NET软件栈包含两个主要部分：提供者和服务。ADO.NET的“提供者”是一些组件，这些组件知道如何与特定的数据存储设施交互（例如，有一个提供者与SQL Server交互，另一个提供者与Oracle数据库交互）。所有的提供者都向外提供一个统一的API接口，ADO.NET软件栈中的其他层在此API之上建立。ADO.NET还包括基于提供者而建立的一些服务，设计这些服务的目的，是为了方便编写应用程序。其中一个服务是内存中的缓存（in-memory cache），缓存保存了数据的关系形式，并执行修改跟踪和约束验证等功能；该服务通过ADO.NET DataSet接口提供，包括一些与提供者层进行交互的组件。","text":"ADO.NET概述ADO.NET是一种数据访问技术，使得应用程序可以连接到数据存储，并以各种方式操作存储在其中的数据。该技术基于.NET Framework，与.NET Framework类库的其余部分高度集成。ADO.NET API的设计，使得可以从所有面向.NET Framework的语言中使用该API，如Visual Basic、C#、J#、和Visual C++。ADO.NET软件栈包含两个主要部分：提供者和服务。ADO.NET的“提供者”是一些组件，这些组件知道如何与特定的数据存储设施交互（例如，有一个提供者与SQL Server交互，另一个提供者与Oracle数据库交互）。所有的提供者都向外提供一个统一的API接口，ADO.NET软件栈中的其他层在此API之上建立。ADO.NET还包括基于提供者而建立的一些服务，设计这些服务的目的，是为了方便编写应用程序。其中一个服务是内存中的缓存（in-memory cache），缓存保存了数据的关系形式，并执行修改跟踪和约束验证等功能；该服务通过ADO.NET DataSet接口提供，包括一些与提供者层进行交互的组件。 ADO.NET数据库连接方式分为两种 windows身份验证 server=服务器名;database=数据库名;integrated security=true sql Server身份验证 server=服务器名;database=数据库名;uid=用户名;pwd=密码 ADO.NET五大对象 Connection(数据库连接对象) Command(执行SQL语句，曾删改命令) DataAdapte(执行SQL查询语句，断开式查询) DataReader(执行SQL语句，非断开式查询) DataSet(数据集) 引入名称空间 using System.Data.SqlClient; using System.Data; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293using System;using System.Data.SqlClient;using System.Data;namespace CinemaTicketSystem&#123; class DBHelper &#123; //创建链接数据库字符串 private static string ConnStr = \"server=.;database=DarkNet;integrated security=true\"; //创建链接数据库对象 private static SqlConnection Conn = new SqlConnection(ConnStr);; /// &lt;summary&gt; /// 链接数据库 /// &lt;/summary&gt; private static void InitConnection() &#123; //判断数据库是否关闭，关闭则打开数据库 if (Conn.State == ConnectionState.Closed) &#123; Conn.Open(); &#125; //判断数据库是否处于中断状态，中断则先关闭数据库再打开数据库 if (Conn.State == ConnectionState.Broken) &#123; Conn.Close(); Conn.Open(); &#125; &#125; /// &lt;summary&gt; /// 断开试查询 /// &lt;/summary&gt; /// &lt;param name=\"sqlStr\"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static DataTable GetDataTable(string sqlStr) &#123; InitConnection(); SqlDataAdapter sda = new SqlDataAdapter(sqlStr, Conn); DataTable td = new DataTable(); sda.Fill(td); Conn.Close(); return td; &#125; /// &lt;summary&gt; /// 非断开试查询 /// &lt;/summary&gt; /// &lt;param name=\"sqlStr\"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static SqlDataReader GetDataReader(string sqlStr) &#123; InitConnection(); SqlCommand cmd = new SqlCommand(sqlStr, Conn); return cmd.ExecuteReader(CommandBehavior.CloseConnection); &#125; /// &lt;summary&gt; /// 增删改 /// &lt;/summary&gt; /// &lt;param name=\"sqlStr\"&gt;sql语句&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static bool ExecuteNoneQuery(string sqlStr) &#123; InitConnection(); SqlCommand cmd = new SqlCommand(sqlStr, Conn); bool rel = cmd.ExecuteNonQuery() &gt; 0; Conn.Close(); return rel; &#125; /// &lt;summary&gt; /// 执行聚合函数 /// &lt;/summary&gt; /// &lt;param name=\"sqlStr\"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static object ExecuteScalar(string sqlStr) &#123; InitConnection(); SqlCommand cmd = new SqlCommand(sqlStr, Conn); object rel = cmd.ExecuteScalar(); Conn.Close(); return rel; &#125; &#125;&#125;","categories":[],"tags":[{"name":"c# .net","slug":"c-net","permalink":"http://yoursite.com/tags/c-net/"}]}]}