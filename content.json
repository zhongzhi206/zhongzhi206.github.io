{"meta":{"title":"悠哉码农的日常","subtitle":null,"description":null,"author":"悠哉码农的日常","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2019-09-27T12:38:44.000Z","updated":"2019-09-27T12:38:44.554Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"c#面向对象之字典集合Hashtable","slug":"c-面向对象之字典集合Hashtable","date":"2019-09-26T13:56:07.000Z","updated":"2019-09-26T15:33:25.898Z","comments":true,"path":"2019/09/26/c-面向对象之字典集合Hashtable/","link":"","permalink":"http://yoursite.com/2019/09/26/c-面向对象之字典集合Hashtable/","excerpt":"Hashtable概述在.NET中，Hashtable是用来处理 Key/Value（键/值）对的集合容器。其中Key通常用来快速查找，Value用来储存对应的Key值，Key区分大小写，Hashtable的Key和Values均为Object类型，所以在访问的时候要把类型从Object类型转换为原来的类型。相对于ArrayList，Hashtable更方便查找指定元素。","text":"Hashtable概述在.NET中，Hashtable是用来处理 Key/Value（键/值）对的集合容器。其中Key通常用来快速查找，Value用来储存对应的Key值，Key区分大小写，Hashtable的Key和Values均为Object类型，所以在访问的时候要把类型从Object类型转换为原来的类型。相对于ArrayList，Hashtable更方便查找指定元素。 Hashtable常用属性及方法Hashtable常用属性 属性 说明 Keys 获取包含Hashtable中所有键的ICollection,可以遍历该属性访问Hashtable中所有键 Values 获取包含Hashtable中所有值的ICollection,可以遍历该属性访问Hashtable中所有值 Count 获取Hashtable中键/值对的数目 Hashtable常用方法 方法 说明 Add(obgect keys,object values) 将带有指定键和值的元素添加到Hashtable中 Remove(object key) 删除Hashtable中指定键的元素 Clear() 清空Hashtable中所有的元素 ContainKey(object key) 判断Hashtable中是否包含指定键，该方法返回bool类型值 ContinVlue(object value) 判断Hashtable中是否包含指定值，该方法返回bool类型值 ps: 在Hashtable中的元素不需要按顺序储存，所以没有关于排序的方法 Hashtable的使用新建一个Student类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace ConsoleApp11&#123; class Student &#123; private string name; private int age; private bool sexCode; private char sex; public string Name &#123; get &#123; return name; &#125; set &#123; name = value; &#125; &#125; public int Age &#123; get &#123; return age; &#125; set &#123; age = value; &#125; &#125; public bool SexCode &#123; get &#123; return sexCode; &#125; set &#123; sexCode = value; &#125; &#125; public char Sex &#123; get &#123; if (SexCode == true) sex = '男'; else sex = '女'; return sex; &#125; &#125; /// &lt;summary&gt; /// 显示学生信息 /// &lt;/summary&gt; public void Show() &#123; Console.WriteLine(\"姓名：&#123;0&#125;，性别：&#123;1&#125;，年龄：&#123;2&#125;\", Name, Sex, Age); &#125; /// &lt;summary&gt; /// 用户查询学生姓名时显示对应的学生信息 /// &lt;/summary&gt; /// &lt;param name=\"name\"&gt;&lt;/param&gt; public void Show(string name) &#123; Console.WriteLine(\"你查询学生的信息如下\"); Console.WriteLine(\"姓名：&#123;0&#125;，性别：&#123;1&#125;，年龄：&#123;2&#125;\", Name, Sex, Age); &#125; &#125;&#125; 在Main函数中使用Hashtable，调用Student类 1234567891011121314151617181920212223242526272829303132333435//实例化两个学生类，添加两个学生Student zhong = new Student() &#123; Name = \"钟\", SexCode = true, Age = 19 &#125;;Student zhi = new Student() &#123; Name = \"智\", SexCode = false, Age = 19 &#125;;//实例化一个字典集合Hashtable,把学生的信息存入HashtableHashtable hst = new Hashtable();//存入学生信息，第一个参数是键 Keys（这里以学生的姓名为键），第二个参数是值 values （这里以学生信息对象为值）。//键和值 Keys&amp;&amp;Values 均为Object类型，所以在访问键值的时候都要转回储存前的类型hst.Add(zhong.Name,zhong);hst.Add(zhi.Name,zhi);//删除指定键的内容//hst.Remove(zhong.Name);//判断是否存在键，该值为bool值hst.ContainsKey(zhong.Name);//判断是否存在该内容，该值为bool值hst.ContainsValue(zhong);//用户输入学生信息Console.WriteLine(\"请输入你要查询学生的姓名\");string name= Console.ReadLine();//查询用户输入学生姓名，在Hashtable钟找出该学生的信息Student stu = hst[name] as Student;try&#123; //打印出该学生的信息 stu.Show(name);&#125;catch (Exception)&#123; //若查询不到则提示该学生信息不存在 Console.WriteLine(\"该学生信息不存在\");&#125;Console.ReadKey();","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"微信小程序实现横向滚动条功能","slug":"微信小程序实现横向滚动条功能","date":"2019-09-17T10:16:05.000Z","updated":"2019-09-18T07:42:49.135Z","comments":true,"path":"2019/09/17/微信小程序实现横向滚动条功能/","link":"","permalink":"http://yoursite.com/2019/09/17/微信小程序实现横向滚动条功能/","excerpt":"在微信小程序中实现用户可滑动的横向滚动导航栏效果","text":"在微信小程序中实现用户可滑动的横向滚动导航栏效果 效果图 导航栏的文本用户是可以滑动的 实现方法 在当前页面的js文件中的data块儿定义一个导航栏的文本数据集 1234567891011121314151617181920212223// 导航栏文本nvalist:[ &#123; text: '首页' &#125;, &#123; text: '动画' &#125;, &#123; text: '番剧' &#125;, &#123; text: '动画' &#125;, &#123; text: '国创' &#125;, &#123; text: '音乐' &#125;, &#123; text: '舞蹈' &#125;, &#123; text: '科技' &#125;, &#123; text: '游戏' &#125;, &#123; text: '娱乐' &#125;, &#123; text: '鬼畜' &#125;, &#123; text: '电影' &#125;, &#123; text: '电视剧' &#125;, &#123; text: '纪录片' &#125;, &#123; text: '影视' &#125;, &#123; text: '时尚' &#125;, &#123; text: '生活' &#125;, &#123; text: '广告' &#125;, &#123; text: '直播' &#125;, &#123; text: '相簿' &#125;,] 在wxml文件中书写如下标签,用来循环遍历在js中的导航栏文本 12345&lt;scroll-view class=\"nav\" scroll-x&gt;&lt;view bindtap=\"activeNav\" data-index=\"&#123;&#123;index&#125;&#125;\" class=\"nav_item &#123;&#123;index==currenentIndexNav?'active':''&#125;&#125;\" wx:for=\"&#123;&#123;nvalist&#125;&#125;\" wx:key=\"&#123;&#123;index&#125;&#125;\"&gt;&#123;&#123;item.text&#125;&#125;&lt;/view&gt;&lt;/scroll-view&gt; 在js中判断用户点击文本的索引值 12345678//定义被点击菜单的索引值 currenentIndexNav: 0, // 当用户点击文本后，显示相应的导航栏文本模块 activeNav(e)&#123; this.setData(&#123; currenentIndexNav:e.target.dataset.index &#125;) &#125;, wxss样式 123456789101112.nav&#123; white-space: nowrap; padding: 10rpx;&#125;.nav_item&#123; padding: 20rpx 45rpx; font-size: 30rpx; display: inline-block;&#125;.nav_item.active&#123; border-bottom: 5rpx solid pink;&#125;","categories":[],"tags":[]},{"title":"git命令基础篇","slug":"git命令基础","date":"2019-09-02T10:30:53.000Z","updated":"2019-09-07T09:05:18.754Z","comments":true,"path":"2019/09/02/git命令基础/","link":"","permalink":"http://yoursite.com/2019/09/02/git命令基础/","excerpt":"git是一款开源分布式管理控制系统，可以方便管理储存代码，托管你的代码，支持代码回滚，即回到过去git安装git安装地址 使用前配置配置用户信息与邮箱 git config –global user.name “你的账号”git config –global user.email “你的邮箱”","text":"git是一款开源分布式管理控制系统，可以方便管理储存代码，托管你的代码，支持代码回滚，即回到过去git安装git安装地址 使用前配置配置用户信息与邮箱 git config –global user.name “你的账号”git config –global user.email “你的邮箱” git工作流查看用户配置信息 git config –list 创建本地仓库 git init 创建文件夹 mkdir 文件夹名 创建文件 touch 文件名.html 删除文件 rm -rf 文件名 修改文件名 git mv file newfile (例如将a.txt修改为b.txt 命令: git mv a.txt b.txt) 提交代码到远端的4个步骤：查看文件状态（是否被提交，可省略） git status 添加文件到暂存区 git add 文件名 git add . 表示添加当前文件下所有文件 取消暂存区文件 git reset HEAD 文件名 填写提交信息 git commit -m “提交信息”跳过git add流程，自动把跟踪的文件全部提交git commit -a -m ‘added new benchmarks’ 将本地仓库推送到远端： git push 本地与远端同步： git pull 分支管理创建分支： git branch 分支名 切换分支： git checkout 分支名 创建并切换分支： git checkout -b 分支 （即创建分支与切换分支合并成一条命令） 分支合并： git merge 分支名 删除分支： git branch -d 分支名","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"使用CMD满速下载百度云","slug":"使用CMD满速下载百度云","date":"2019-08-07T13:10:59.000Z","updated":"2019-08-09T14:39:04.352Z","comments":true,"path":"2019/08/07/使用CMD满速下载百度云/","link":"","permalink":"http://yoursite.com/2019/08/07/使用CMD满速下载百度云/","excerpt":"工具准备 windows 10电脑 下载工具：baidupcs-go win10打开CDM快捷键 win+R后输入CMD回车 环境配置 桌面右击我的电脑→属性→高级系统设置→环境变量 在系统变量中选择Path变量→编辑→新建→输入你的BaiduPCS-Go的存放目录，注意是存放目录，例如我的是 D:\\BaiduPCS-Go-v3.5.6-windows-x64，最后依次确认这样才可以使用CMD命令快速打开baidupcs-go","text":"工具准备 windows 10电脑 下载工具：baidupcs-go win10打开CDM快捷键 win+R后输入CMD回车 环境配置 桌面右击我的电脑→属性→高级系统设置→环境变量 在系统变量中选择Path变量→编辑→新建→输入你的BaiduPCS-Go的存放目录，注意是存放目录，例如我的是 D:\\BaiduPCS-Go-v3.5.6-windows-x64，最后依次确认这样才可以使用CMD命令快速打开baidupcs-go 使用教程登录 配置好环境变量后，打开cmd 输入命令：baidupcs-go回车 登录你的百度网盘账号 输入命令 login回车依次输入账户密码，注意CMD中输入密码是不会显示出来的（哪怕是*号也不会显示）。 复制路径在文件管理器中粘贴打开 选择验证方式文件下载 列出当前位置所有文件 输入命令 ls 列出当前位置所有文件 选择目录（选择文件夹） cd 目录（只要输入前几个字按tab键就可以自动补全目录） 下载文件 d 文件名 总结至此，基本使用教程已经讲完了，也可以登录后输入命令‘help’查看命令集,如有其它问题前往 https://github.com/iikira/BaiduPCS-Go以获取更多帮助信息!前往 https://github.com/iikira/BaiduPCS-Go/releases 以获取程序更新信息!","categories":[],"tags":[{"name":"-百度云","slug":"百度云","permalink":"http://yoursite.com/tags/百度云/"}]},{"title":"winform实现B窗体刷新A窗体（子窗体刷新父窗体）","slug":"winform实现A窗体刷新B窗体","date":"2019-08-02T14:02:00.000Z","updated":"2019-08-05T06:32:18.019Z","comments":true,"path":"2019/08/02/winform实现A窗体刷新B窗体/","link":"","permalink":"http://yoursite.com/2019/08/02/winform实现A窗体刷新B窗体/","excerpt":"前言最近博主在做项目的时候遇到需要实现A窗体刷新B窗体的功能，比如从A窗体中点击登录按钮弹出B窗体的登录界面，如果用户登录成功则自动关闭B窗体，A窗体显示用户昵称；当用户关闭登录界面时，什么都不改变。","text":"前言最近博主在做项目的时候遇到需要实现A窗体刷新B窗体的功能，比如从A窗体中点击登录按钮弹出B窗体的登录界面，如果用户登录成功则自动关闭B窗体，A窗体显示用户昵称；当用户关闭登录界面时，什么都不改变。 效果流程 在A窗体中当用户点击登录，弹出B窗体登录界面，如果登录成功，则把A窗体用户名改成用户在B窗体输入的用户名 用户输入账户后，把账户传到A窗体中 解决方案实现窗体间的传值 重载A窗体中的构造方法，并定义一个string类型的全局变量，注意：必须加static关键字，否则不能传值 1234567891011121314//系统自动生成的构造函数 public Form1() &#123; InitializeComponent(); &#125; //定义一个string类型的全局变量 private static string UserName = \"\"; //重载构造函数，设置一个string类型的形参，用来接收从B窗体传来的值 public Form1(string str) &#123; //把传过来的参数赋值给UserName UserName = str; &#125; 在A窗体中定义一个方法，把要刷新的部分写到这个方法里面 12345public void ShuaXin()&#123; //吧用户名标签文本改成用户传过来的值 label1.Text = UserName;&#125; 在A窗体里点击触发B窗体的按钮里的代码如下 123456private void button1_Click(object sender, EventArgs e)&#123; Login login = new Login(); login.Owner = this; login.Show();&#125; 在B窗体登录按钮单击事件的代码如下 1234567private void button1_Click(object sender, EventArgs e)&#123; Form1 form1 = new Form1(textBox1.Text);//把用户输入的账户传到我们刚刚设置好的构造函数里 form1 = (Form1)Owner; form1.ShuaXin(); Close();&#125; 这样就可以实现我们的功能啦。","categories":[],"tags":[]},{"title":"ADO.NET连接数据库(DBHelper类)","slug":"ADO.NET连接数据库(DBHelper类)","date":"2019-07-28T12:11:11.000Z","updated":"2019-09-07T09:24:25.877Z","comments":true,"path":"2019/07/28/ADO.NET连接数据库(DBHelper类)/","link":"","permalink":"http://yoursite.com/2019/07/28/ADO.NET连接数据库(DBHelper类)/","excerpt":"ADO.NET概述ADO.NET是一种数据访问技术，使得应用程序可以连接到数据存储，并以各种方式操作存储在其中的数据。该技术基于.NET Framework，与.NET Framework类库的其余部分高度集成。ADO.NET API的设计，使得可以从所有面向.NET Framework的语言中使用该API，如Visual Basic、C#、J#、和Visual C++。ADO.NET软件栈包含两个主要部分：提供者和服务。ADO.NET的“提供者”是一些组件，这些组件知道如何与特定的数据存储设施交互（例如，有一个提供者与SQL Server交互，另一个提供者与Oracle数据库交互）。所有的提供者都向外提供一个统一的API接口，ADO.NET软件栈中的其他层在此API之上建立。ADO.NET还包括基于提供者而建立的一些服务，设计这些服务的目的，是为了方便编写应用程序。其中一个服务是内存中的缓存（in-memory cache），缓存保存了数据的关系形式，并执行修改跟踪和约束验证等功能；该服务通过ADO.NET DataSet接口提供，包括一些与提供者层进行交互的组件。","text":"ADO.NET概述ADO.NET是一种数据访问技术，使得应用程序可以连接到数据存储，并以各种方式操作存储在其中的数据。该技术基于.NET Framework，与.NET Framework类库的其余部分高度集成。ADO.NET API的设计，使得可以从所有面向.NET Framework的语言中使用该API，如Visual Basic、C#、J#、和Visual C++。ADO.NET软件栈包含两个主要部分：提供者和服务。ADO.NET的“提供者”是一些组件，这些组件知道如何与特定的数据存储设施交互（例如，有一个提供者与SQL Server交互，另一个提供者与Oracle数据库交互）。所有的提供者都向外提供一个统一的API接口，ADO.NET软件栈中的其他层在此API之上建立。ADO.NET还包括基于提供者而建立的一些服务，设计这些服务的目的，是为了方便编写应用程序。其中一个服务是内存中的缓存（in-memory cache），缓存保存了数据的关系形式，并执行修改跟踪和约束验证等功能；该服务通过ADO.NET DataSet接口提供，包括一些与提供者层进行交互的组件。 ADO.NET数据库连接方式分为两种 windows身份验证 server=服务器名;database=数据库名;integrated security=true sql Server身份验证 server=服务器名;database=数据库名;uid=用户名;pwd=密码 ADO.NET五大对象 Connection(数据库连接对象) Command(执行SQL语句，曾删改命令) DataAdapte(执行SQL查询语句，断开式查询) DataReader(执行SQL语句，非断开式查询) DataSet(数据集) 引入名称空间 using System.Data.SqlClient; using System.Data; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293using System;using System.Data.SqlClient;using System.Data;namespace CinemaTicketSystem&#123; class DBHelper &#123; //创建链接数据库字符串 private static string ConnStr = \"server=.;database=DarkNet;integrated security=true\"; //创建链接数据库对象 private static SqlConnection Conn = new SqlConnection(ConnStr);; /// &lt;summary&gt; /// 链接数据库 /// &lt;/summary&gt; private static void InitConnection() &#123; //判断数据库是否关闭，关闭则打开数据库 if (Conn.State == ConnectionState.Closed) &#123; Conn.Open(); &#125; //判断数据库是否处于中断状态，中断则先关闭数据库再打开数据库 if (Conn.State == ConnectionState.Broken) &#123; Conn.Close(); Conn.Open(); &#125; &#125; /// &lt;summary&gt; /// 断开试查询 /// &lt;/summary&gt; /// &lt;param name=\"sqlStr\"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static DataTable GetDataTable(string sqlStr) &#123; InitConnection(); SqlDataAdapter sda = new SqlDataAdapter(sqlStr, Conn); DataTable td = new DataTable(); sda.Fill(td); Conn.Close(); return td; &#125; /// &lt;summary&gt; /// 非断开试查询 /// &lt;/summary&gt; /// &lt;param name=\"sqlStr\"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static SqlDataReader GetDataReader(string sqlStr) &#123; InitConnection(); SqlCommand cmd = new SqlCommand(sqlStr, Conn); return cmd.ExecuteReader(CommandBehavior.CloseConnection); &#125; /// &lt;summary&gt; /// 增删改 /// &lt;/summary&gt; /// &lt;param name=\"sqlStr\"&gt;sql语句&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static bool ExecuteNoneQuery(string sqlStr) &#123; InitConnection(); SqlCommand cmd = new SqlCommand(sqlStr, Conn); bool rel = cmd.ExecuteNonQuery() &gt; 0; Conn.Close(); return rel; &#125; /// &lt;summary&gt; /// 执行聚合函数 /// &lt;/summary&gt; /// &lt;param name=\"sqlStr\"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static object ExecuteScalar(string sqlStr) &#123; InitConnection(); SqlCommand cmd = new SqlCommand(sqlStr, Conn); object rel = cmd.ExecuteScalar(); Conn.Close(); return rel; &#125; &#125;&#125;","categories":[],"tags":[{"name":"c# .net","slug":"c-net","permalink":"http://yoursite.com/tags/c-net/"}]}]}